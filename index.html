<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>GPX Hiker - Planer Puszczy Wkrza≈Ñskiej</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet & Plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>

    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #f1f5f9;
            --accent: #22c55e;
            --danger: #ef4444;
            --modal-bg: rgba(15, 23, 42, 0.95);
        }
        .light {
            --bg: #f8fafc;
            --panel: #ffffff;
            --text: #0f172a;
            --accent: #16a34a;
            --modal-bg: rgba(255, 255, 255, 0.95);
        }
        body {
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 350px 1fr;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        aside {
            background: var(--panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        h3 { margin-top: 0; color: var(--accent); }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            border: none;
            padding: 10px;
            border-radius: 6px;
            background: var(--accent);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        
        .stat-card {
            background: rgba(0,0,0,0.1);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }
        .stat-val { font-size: 1.2em; font-weight: bold; display: block; }
        
        #map { height: 100%; width: 100%; background: #ddd; }
        
        canvas#elevation {
            height: 120px;
            width: 100%;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        /* Modal Styles */
        #pointsModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            background: var(--panel);
            color: var(--text);
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            flex-direction: column;
            padding: 20px;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .modal-body { overflow-y: auto; flex-grow: 1; }
        .point-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .point-info { flex-grow: 1; }
        .point-actions { display: flex; gap: 5px; }
        .point-actions button { padding: 5px 8px; font-size: 0.8em; }

        .overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1999;
            display: none;
        }

        .controls { font-size: 0.85em; background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; }
        hr { border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 10px 0; }
        
        @media (max-width: 768px) {
            body { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            aside { height: auto; max-height: 40vh; }
        }
    </style>
</head>
<body class="dark">

<aside>
    <h3>üå≤ GPX Hiker<br><small>Puszcza Wkrza≈Ñska</small></h3>

    <div class="btn-group">
        <button onclick="toggleTheme()">üåì Motyw</button>
        <button onclick="takeScreenshot()">üì∏ Zdjƒôcie</button>
    </div>

    <div class="btn-group">
        <button class="secondary" onclick="exportGPX()">‚¨áÔ∏è Zapisz GPX</button>
        <button class="secondary" onclick="document.getElementById('fileInput').click()">‚¨ÜÔ∏è Wczytaj</button>
    </div>
    <input type="file" id="fileInput" hidden accept=".gpx" onchange="importGPX(event)">

    <button onclick="openPointsModal()">üìë Punkty Trasy (Edycja)</button>
    <button onclick="enablePOI()">üìç Dodaj Opisany Punkt</button>
    <button class="danger" onclick="clearAll()">üóëÔ∏è Wyczy≈õƒá wszystko</button>

    <hr>

    <div class="controls">
        <label><input type="checkbox" checked onchange="toggleLayer(hikingLayer, this)"> ü•æ Szlaki turystyczne</label><br>
        <label><input type="checkbox" checked onchange="toggleLayer(poiLayer, this)"> üõñ Wiaty i atrakcje</label>
    </div>

    <div class="stat-card">
        <span class="stat-val" id="stats">0.00 km</span>
        <small id="time">Czas: 0 min | ‚õ∞Ô∏è Suma podej≈õƒá: 0m</small>
    </div>

    <div>
        <small>Profil wysoko≈õci trasy:</small>
        <canvas id="elevation"></canvas>
    </div>

    <div class="controls" style="margin-top: auto;">
        <strong>Szybka pomoc:</strong><br>
        ‚Ä¢ Lewy klik: Dodaj punkt trasy.<br>
        ‚Ä¢ Prawy klik na marker: Usu≈Ñ punkt.<br>
        ‚Ä¢ Panel edycji: Zmie≈Ñ kolejno≈õƒá.
    </div>
</aside>

<div id="map"></div>

<!-- MODAL EDYCJI PUNKT√ìW -->
<div class="overlay" id="overlay" onclick="closePointsModal()"></div>
<div id="pointsModal">
    <div class="modal-header">
        <h3>üìç Lista Punkt√≥w Trasy</h3>
        <button class="danger" onclick="closePointsModal()">X</button>
    </div>
    <div class="modal-body" id="pointsList">
        <!-- Punkty generowane dynamicznie -->
    </div>
</div>

<script>
/* ================= KONFIGURACJA MAPY ================= */
const map = L.map('map', { 
    zoomControl: false,
    preferCanvas: true 
}).setView([53.50, 14.50], 12);

L.control.zoom({ position: 'topright' }).addTo(map);

let dark = true;
const tiles = {
    dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OSM', crossOrigin: true }),
    light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', crossOrigin: true })
};
tiles.dark.addTo(map);

/* ================= STAN APLIKACJI ================= */
let routePoints = []; 
let routeGeometry = []; 
let pois = [];
let poiMode = false;
let totalAscent = 0;

const polyline = L.polyline([], {color: '#22c55e', weight: 6, opacity: 0.9, lineJoin: 'round'}).addTo(map);
const hikingLayer = L.layerGroup().addTo(map);
const poiLayer = L.layerGroup().addTo(map);

const osmTranslations = {
    'shelter': 'Wiata', 'drinking_water': 'Woda', 'viewpoint': 'Widok',
    'picnic_site': 'Piknik', 'information': 'Info', 'parking': 'Parking'
};

/* ================= SILNIK TRASOWANIA (OSRM) ================= */
async function getRouteSegment(start, end) {
    try {
        const url = `https://router.project-osrm.org/route/v1/foot/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson&continue_straight=true`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("OSRM error");
        const data = await resp.json();
        
        if (data.code === 'Ok' && data.routes.length > 0) {
            return {
                coords: data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]),
                distance: data.routes[0].distance
            };
        }
        throw new Error("Route not found");
    } catch (e) {
        return { coords: [[start.lat, start.lng], [end.lat, end.lng]], distance: 0 }; 
    }
}

/* ================= OBS≈ÅUGA PUNKT√ìW ================= */
map.on('click', async e => {
    if (poiMode) { addPOI(e.latlng); poiMode = false; return; }
    await addRoutePoint(e.latlng);
});

async function addRoutePoint(latlng) {
    const pointId = Date.now();
    const m = L.circleMarker(latlng, { 
        radius: 8, color: '#fff', weight: 3, fillColor: '#22c55e', fillOpacity: 1, zIndexOffset: 1000 
    }).addTo(map);
    
    m.on('contextmenu', (ev) => {
        L.DomEvent.stopPropagation(ev);
        removePointById(pointId);
    });

    const elev = await getElevation(latlng.lat, latlng.lng);
    
    routePoints.push({
        id: pointId,
        latlng: latlng,
        marker: m,
        elevation: elev,
        distFromPrev: 0
    });

    recalculateRoute();
}

async function recalculateRoute() {
    routeGeometry = [];
    totalAscent = 0;
    
    if (routePoints.length === 0) {
        polyline.setLatLngs([]);
        updateStats(0);
        return;
    }

    routeGeometry = [[routePoints[0].latlng.lat, routePoints[0].latlng.lng]];
    
    for (let i = 1; i < routePoints.length; i++) {
        const res = await getRouteSegment(routePoints[i-1].latlng, routePoints[i].latlng);
        routePoints[i].distFromPrev = res.distance;
        routeGeometry = routeGeometry.concat(res.coords.slice(1));
    }

    polyline.setLatLngs(routeGeometry);
    const totalDist = calculateTotalDist();
    updateStats(totalDist);
    fetchFullElevationProfile();
}

function removePointById(id) {
    const idx = routePoints.findIndex(p => p.id === id);
    if (idx > -1) {
        map.removeLayer(routePoints[idx].marker);
        routePoints.splice(idx, 1);
        recalculateRoute();
        renderPointsList();
    }
}

function movePoint(idx, direction) {
    if (direction === 'up' && idx > 0) {
        [routePoints[idx], routePoints[idx-1]] = [routePoints[idx-1], routePoints[idx]];
    } else if (direction === 'down' && idx < routePoints.length - 1) {
        [routePoints[idx], routePoints[idx+1]] = [routePoints[idx+1], routePoints[idx]];
    }
    recalculateRoute();
    renderPointsList();
}

/* ================= WYSOKO≈öCI I STATYSTYKI ================= */
async function getElevation(lat, lng) {
    try {
        const res = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const data = await res.json();
        return data.results[0].elevation;
    } catch(e) { return 0; }
}

async function fetchFullElevationProfile() {
    if (routeGeometry.length < 2) { clearElevation(); return; }
    const step = Math.max(1, Math.floor(routeGeometry.length / 40));
    const sampled = routeGeometry.filter((_, i) => i % step === 0);
    const locs = sampled.map(p => ({ latitude: p[0], longitude: p[1] }));
    
    try {
        const res = await fetch(`https://api.open-elevation.com/api/v1/lookup`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ locations: locs })
        });
        const data = await res.json();
        const elevations = data.results.map(r => r.elevation);
        
        let ascent = 0;
        for(let i=1; i<elevations.length; i++) {
            if(elevations[i] > elevations[i-1]) ascent += (elevations[i] - elevations[i-1]);
        }
        totalAscent = Math.round(ascent);
        const dist = calculateTotalDist();
        updateStats(dist);
        drawElevation(elevations);
    } catch (e) { console.error("Elevation error"); }
}

function calculateTotalDist() {
    let d = 0;
    for (let i = 1; i < routeGeometry.length; i++) {
        d += L.latLng(routeGeometry[i-1]).distanceTo(L.latLng(routeGeometry[i]));
    }
    return d;
}

function updateStats(distMeters) {
    const km = distMeters / 1000;
    document.getElementById('stats').innerText = `${km.toFixed(2)} km`;
    const speed = 4.2;
    const minutes = (km / speed) * 60 + (totalAscent / 100 * 10);
    document.getElementById('time').innerText = `Czas: ok. ${Math.round(minutes)} min | ‚õ∞Ô∏è Podej≈õcia: ${totalAscent}m`;
}

function clearElevation() {
    const c = document.getElementById('elevation');
    c.getContext('2d').clearRect(0,0,c.width,c.height);
}

function drawElevation(data) {
    const c = document.getElementById('elevation');
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    c.width = c.offsetWidth * dpr;
    c.height = c.offsetHeight * dpr;
    ctx.scale(dpr, dpr);
    const w = c.offsetWidth;
    const h = c.offsetHeight;
    const min = Math.min(...data) - 5;
    const max = Math.max(...data) + 10;
    const range = max - min;

    ctx.clearRect(0,0,w,h);
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, 'rgba(34, 197, 94, 0.4)');
    grad.addColorStop(1, 'transparent');

    ctx.beginPath();
    ctx.moveTo(0, h);
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * h;
        ctx.lineTo(x, y);
    });
    ctx.lineTo(w, h);
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * h;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 3;
    ctx.stroke();
}

/* ================= MODAL I LISTA ================= */
function openPointsModal() {
    document.getElementById('overlay').style.display = 'block';
    document.getElementById('pointsModal').style.display = 'flex';
    renderPointsList();
}

function closePointsModal() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('pointsModal').style.display = 'none';
}

function renderPointsList() {
    const list = document.getElementById('pointsList');
    list.innerHTML = routePoints.length === 0 ? "<p>Brak punkt√≥w na trasie.</p>" : "";
    routePoints.forEach((p, i) => {
        const item = document.createElement('div');
        item.className = 'point-item';
        const distText = i === 0 ? "START" : `+${(p.distFromPrev/1000).toFixed(2)} km`;
        item.innerHTML = `
            <div class="point-info">
                <strong>Punkt ${i + 1}</strong> <small>(${p.elevation} m n.p.m.)</small><br>
                <span>${distText}</span>
            </div>
            <div class="point-actions">
                <button class="secondary" onclick="movePoint(${i}, 'up')" ${i===0?'disabled':''}>‚Üë</button>
                <button class="secondary" onclick="movePoint(${i}, 'down')" ${i===routePoints.length-1?'disabled':''}>‚Üì</button>
                <button class="danger" onclick="removePointById(${p.id})">üóëÔ∏è</button>
            </div>
        `;
        list.appendChild(item);
    });
}

/* ================= DANE OSM (SZLAKI I POI) ================= */
async function loadOSMData() {
    // Rozmiar ograniczony dla stabilno≈õci zapytania
    const query = `[out:json][timeout:25];
    (
      relation["route"="hiking"](53.4,14.3,53.6,14.7);
      node["amenity"~"shelter|drinking_water|parking"](53.4,14.3,53.6,14.7);
      node["tourism"~"viewpoint|picnic_site|information"](53.4,14.3,53.6,14.7);
    );
    out body;
    >;
    out skel qt;`;

    try {
        const resp = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
        if (!resp.ok) throw new Error("Overpass timeout");
        const data = await resp.json();

        // Przetwarzanie relacji (szlaki)
        const nodes = {};
        data.elements.filter(e => e.type === "node").forEach(n => nodes[n.id] = [n.lat, n.lon]);

        const ways = {};
        data.elements.filter(e => e.type === "way").forEach(w => ways[w.id] = w.nodes.map(nid => nodes[nid]));

        data.elements.filter(e => e.type === "relation").forEach(rel => {
            const colorTag = (rel.tags.osmc_symbol || rel.tags.color || "").toLowerCase();
            let color = '#888'; // domy≈õlny
            
            if (colorTag.includes('red')) color = '#ef4444';
            else if (colorTag.includes('blue')) color = '#3b82f6';
            else if (colorTag.includes('green')) color = '#22c55e';
            else if (colorTag.includes('yellow')) color = '#eab308';
            else if (colorTag.includes('black')) color = '#000000';

            rel.members.forEach(m => {
                if (m.type === "way" && ways[m.ref]) {
                    L.polyline(ways[m.ref], {
                        color: color, weight: 4, opacity: 0.7, dashArray: '8, 8'
                    }).bindTooltip(rel.tags.name || "Szlak").addTo(hikingLayer);
                }
            });
        });

        // Przetwarzanie POI
        data.elements.filter(e => e.type === "node" && e.tags).forEach(e => {
            let icon = 'üìç';
            if(e.tags.amenity === 'shelter') icon = 'üõñ';
            else if(e.tags.tourism === 'viewpoint') icon = 'üî≠';
            else if(e.tags.amenity === 'parking') icon = 'üÖøÔ∏è';

            const typeName = osmTranslations[e.tags.amenity] || osmTranslations[e.tags.tourism] || "Punkt";
            L.marker([e.lat, e.lon], {
                icon: L.divIcon({ html: `<div style="font-size:18px">${icon}</div>`, className: 'poi-icon' })
            }).bindPopup(`<b>${e.tags.name || typeName}</b>`).addTo(poiLayer);
        });

    } catch (e) {
        console.warn("B≈ÇƒÖd ≈Çadowania danych OSM. Serwer mo≈ºe byƒá przeciƒÖ≈ºony.");
    }
}
loadOSMData();

/* ================= POMOCNICZE ================= */
function toggleTheme() {
    dark = !dark;
    document.body.className = dark ? "dark" : "light";
    map.removeLayer(dark ? tiles.light : tiles.dark);
    (dark ? tiles.dark : tiles.light).addTo(map);
}

function takeScreenshot() {
    const mapEl = document.getElementById('map');
    domtoimage.toPng(mapEl, { width: mapEl.clientWidth, height: mapEl.clientHeight })
    .then(dataUrl => {
        const link = document.createElement('a');
        link.download = 'mapa_puszcza.png';
        link.href = dataUrl;
        link.click();
    });
}

function exportGPX() {
    if (routeGeometry.length < 2) return;
    let gpx = `<?xml version="1.0" encoding="UTF-8"?><gpx version="1.1" creator="GPX Hiker"><trk><trkseg>`;
    routeGeometry.forEach(p => gpx += `<trkpt lat="${p[0]}" lon="${p[1]}"></trkpt>`);
    gpx += `</trkseg></trk></gpx>`;
    const blob = new Blob([gpx], {type: "application/gpx+xml"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "trasa.gpx";
    a.click();
}

function clearAll() {
    routePoints.forEach(p => map.removeLayer(p.marker));
    pois.forEach(p => map.removeLayer(p.marker));
    routePoints = []; routeGeometry = []; pois = [];
    recalculateRoute();
}

function enablePOI() {
    poiMode = true;
    alert("Kliknij na mapƒô, by dodaƒá w≈Çasny opis.");
}

function addPOI(latlng) {
    const name = prompt("Nazwa punktu:");
    if (!name) return;
    const m = L.marker(latlng).addTo(map).bindPopup(`<b>üìç ${name}</b>`).openPopup();
    pois.push({latlng, name, marker: m});
}

function toggleLayer(layer, cb) {
    if (cb.checked) map.addLayer(layer); else map.removeLayer(layer);
}

function importGPX(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
        const xml = new DOMParser().parseFromString(ev.target.result, "text/xml");
        const pts = xml.querySelectorAll("trkpt");
        clearAll();
        for(let p of Array.from(pts).slice(0, 30)) {
            const lat = parseFloat(p.getAttribute("lat"));
            const lon = parseFloat(p.getAttribute("lon"));
            await addRoutePoint(L.latLng(lat, lon));
        }
    };
    reader.readAsText(file);
}
</script>

</body>
</html>
