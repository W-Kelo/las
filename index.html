<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>GPX Hiker - Planer Puszczy Wkrza≈Ñskiej</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Leaflet & Plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>

    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #f1f5f9;
            --accent: #22c55e;
            --danger: #ef4444;
            --modal-bg-color: 30, 41, 59; /* RGB dla panelu dark */
        }
        .light {
            --bg: #f8fafc;
            --panel: #ffffff;
            --text: #0f172a;
            --accent: #16a34a;
            --modal-bg-color: 255, 255, 255; /* RGB dla panelu light */
        }
        body {
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 350px 1fr;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        
        /* Panel Boczny */
        aside {
            background: var(--panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        h3 { margin-top: 0; color: var(--accent); margin-bottom: 5px; }
        .subtitle { font-size: 0.85em; opacity: 0.8; margin-bottom: 15px; display: block;}

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            border: none;
            padding: 10px;
            border-radius: 6px;
            background: var(--accent);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        .stat-card {
            background: rgba(0,0,0,0.1);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }
        
        #map { height: 100%; width: 100%; background: #ddd; position: relative; }
        
        canvas#elevation {
            height: 100px;
            width: 100%;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-top: 5px;
        }

        /* P≈ÇywajƒÖce Modale */
        .floating-modal {
            position: fixed;
            top: 50%; left: 50%;
            width: 400px;
            min-width: 300px;
            min-height: 200px;
            max-width: 90vw;
            max-height: 80vh;
            background: rgba(var(--modal-bg-color), 0.95);
            color: var(--text);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.1);
            resize: both; /* Mo≈ºliwo≈õƒá zmiany rozmiaru */
            overflow: hidden;
        }

        .modal-header { 
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            cursor: move; /* Kursor przesuwania */
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .modal-body { 
            padding: 15px;
            overflow-y: auto; 
            flex-grow: 1;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .opacity-control {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-right: 10px;
        }
        .opacity-control input { width: 60px; accent-color: var(--accent); cursor: pointer; }

        .point-item {
            display: flex; align-items: center; gap: 10px; padding: 10px;
            background: rgba(0,0,0,0.1); border-radius: 8px; margin-bottom: 8px;
        }
        .point-info { flex-grow: 1; }
        
        /* Ukrywamy overlay dla floating modals, ≈ºeby mo≈ºna by≈Ço klikaƒá w mapƒô */
        .overlay { display: none; }

        .controls { font-size: 0.85em; background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; }
        hr { border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 10px 0; }
        
        /* Mobile Controls */
        #mobile-toggle { display: none; position: absolute; top: 10px; left: 10px; z-index: 1100; padding: 10px; border-radius: 50%; width: 45px; height: 45px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        #gps-btn { position: absolute; bottom: 20px; right: 20px; z-index: 900; width: 50px; height: 50px; border-radius: 50%; background: var(--panel); color: var(--accent); box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; border: 2px solid var(--accent); }

        /* Loader */
        .loading-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white; padding: 15px 25px; border-radius: 8px;
            z-index: 2000; font-weight: bold; display: none; pointer-events: none;
        }

        @media (max-width: 768px) {
            body { grid-template-columns: 1fr; }
            aside {
                position: absolute; top: 0; left: 0; width: 85%; height: 100%;
                transform: translateX(-100%);
            }
            aside.open { transform: translateX(0); }
            #mobile-toggle { display: flex; }
            .leaflet-control-zoom { display: none; }
            .floating-modal { width: 95%; left: 2.5% !important; top: 10% !important; height: auto; max-height: 60vh;}
        }
    </style>
</head>
<body class="dark">

<button id="mobile-toggle" onclick="toggleSidebar()">‚ò∞</button>

<aside id="sidebar">
    <div>
        <h3>üå≤ GPX Hiker</h3>
        <span class="subtitle">Planer Puszczy Wkrza≈Ñskiej</span>
    </div>

    <div class="btn-group">
        <button onclick="toggleTheme()">üåì Motyw</button>
        <button onclick="takeScreenshot()">üì∏ Zrzut</button>
    </div>

    <div class="btn-group">
        <button class="secondary" onclick="exportGPX()">‚¨áÔ∏è Eksport</button>
        <button class="secondary" onclick="document.getElementById('fileInput').click()">‚¨ÜÔ∏è Import</button>
    </div>
    <input type="file" id="fileInput" hidden accept=".gpx" onchange="importGPX(event)">

    <button onclick="openPointsModal()">üìë Edytuj Punkty</button>
    <button onclick="openDescModal()">üìú Opis Trasy</button>
    
    <div style="display:grid; grid-template-columns: 1fr; gap: 8px; margin-top: 8px;">
        <button class="secondary" onclick="enablePOI()">üìç Dodaj W≈Çasny Punkt</button>
        <button class="danger" onclick="clearAll()">üóëÔ∏è Nowa Trasa</button>
    </div>

    <hr>

    <div class="controls">
        <label><input type="checkbox" checked onchange="toggleLayer(hikingLayer, this)"> ü•æ Szlaki turystyczne</label><br>
        <label><input type="checkbox" checked onchange="toggleLayer(poiLayer, this)"> üõñ Wiaty i atrakcje</label>
    </div>

    <div class="stat-card">
        <span class="stat-val" id="stats">0.00 km</span>
        <small id="time">Czas: 0 min | ‚õ∞Ô∏è Podej≈õcia: 0m</small>
    </div>

    <div>
        <small>Profil terenu:</small>
        <canvas id="elevation"></canvas>
    </div>
</aside>

<div id="map">
    <div id="loader" class="loading-overlay">‚è≥ Przeliczanie trasy...</div>
</div>
<button id="gps-btn" onclick="locateUser()" title="Zlokalizuj mnie">üéØ</button>

<!-- MODAL EDYCJI PUNKT√ìW -->
<div id="pointsModal" class="floating-modal">
    <div class="modal-header">
        <span>üìç Edycja Punkt√≥w</span>
        <div style="display:flex; align-items:center">
            <div class="opacity-control" title="Przezroczysto≈õƒá">
                üëÅÔ∏è <input type="range" min="20" max="100" value="95" oninput="setOpacity(this)">
            </div>
            <button class="danger icon-only" style="padding: 2px 8px; min-width: auto;" onclick="closeModal('pointsModal')">X</button>
        </div>
    </div>
    <div class="modal-body" id="pointsList"></div>
</div>

<!-- MODAL OPISU TRASY -->
<div id="descModal" class="floating-modal" style="width: 350px;">
    <div class="modal-header">
        <span>üìú Opis Trasy</span>
        <div style="display:flex; align-items:center">
            <div class="opacity-control" title="Przezroczysto≈õƒá">
                üëÅÔ∏è <input type="range" min="20" max="100" value="95" oninput="setOpacity(this)">
            </div>
            <button class="danger icon-only" style="padding: 2px 8px; min-width: auto;" onclick="closeModal('descModal')">X</button>
        </div>
    </div>
    <div class="modal-body" id="routeDescText">
        <em>Zaznacz punkty na mapie, aby wygenerowaƒá opis...</em>
    </div>
</div>

<script>
/* ================= KONFIGURACJA MAPY ================= */
const map = L.map('map', { 
    zoomControl: false,
    preferCanvas: true 
}).setView([53.54, 14.55], 13);

L.control.zoom({ position: 'topright' }).addTo(map);

let dark = true;
const tiles = {
    dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OSM', crossOrigin: true }),
    light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', crossOrigin: true })
};
tiles.dark.addTo(map);

/* ================= STAN APLIKACJI ================= */
let routePoints = []; 
let routeGeometry = []; 
let pois = [];
let poiMode = false;
let totalAscent = 0;
let userMarker = null;
let isRouting = false; 

const polyline = L.polyline([], {color: '#22c55e', weight: 6, opacity: 0.9, lineJoin: 'round'}).addTo(map);
const hikingLayer = L.layerGroup().addTo(map);
const poiLayer = L.layerGroup().addTo(map);

/* ================= OBS≈ÅUGA MODALI (Floating) ================= */
function makeDraggable(el) {
    const header = el.querySelector('.modal-header');
    let isDragging = false;
    let startX, startY, initialLeft, initialTop;

    header.onmousedown = function(e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        initialLeft = el.offsetLeft;
        initialTop = el.offsetTop;
        document.onmousemove = onMouseMove;
        document.onmouseup = stopDrag;
    };

    function onMouseMove(e) {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        el.style.left = (initialLeft + dx) + "px";
        el.style.top = (initialTop + dy) + "px";
        // Reset transformacji centrujƒÖcej, bo u≈ºywamy left/top
        el.style.transform = "none"; 
    }

    function stopDrag() {
        isDragging = false;
        document.onmousemove = null;
        document.onmouseup = null;
    }
}

// Inicjalizacja drag
makeDraggable(document.getElementById('pointsModal'));
makeDraggable(document.getElementById('descModal'));

function openPointsModal() {
    document.getElementById('pointsModal').style.display = 'flex';
    renderPointsList();
}
function openDescModal() {
    document.getElementById('descModal').style.display = 'flex';
    generateRouteDescription();
}
function closeModal(id) {
    document.getElementById(id).style.display = 'none';
}
function setOpacity(input) {
    const val = input.value / 100;
    const modal = input.closest('.floating-modal');
    modal.style.backgroundColor = `rgba(var(--modal-bg-color), ${val})`;
}

/* ================= LOKALIZACJA GPS ================= */
function locateUser() {
    map.locate({setView: true, maxZoom: 15});
}
map.on('locationfound', function(e) {
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.circleMarker(e.latlng, {
        radius: 8, fillColor: "#3b82f6", color: "#fff", weight: 3, opacity: 1, fillOpacity: 1
    }).addTo(map).bindPopup("Twoja pozycja").openPopup();
});

/* ================= IMPORT GPX ================= */
function importGPX(e) {
    if (isRouting) return alert("Poczekaj na zako≈Ñczenie obecnego przeliczania.");
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
        try {
            const xml = new DOMParser().parseFromString(ev.target.result, "text/xml");
            const pts = Array.from(xml.querySelectorAll("trkpt"));
            if (pts.length === 0) throw new Error("Pusty plik GPX");

            clearAll();
            const step = pts.length > 50 ? Math.floor(pts.length / 20) : 1; 
            
            const startLat = parseFloat(pts[0].getAttribute("lat"));
            const startLon = parseFloat(pts[0].getAttribute("lon"));
            await addRoutePoint(L.latLng(startLat, startLon), false);

            for(let i = step; i < pts.length; i += step) {
                const lat = parseFloat(pts[i].getAttribute("lat"));
                const lon = parseFloat(pts[i].getAttribute("lon"));
                await addRoutePoint(L.latLng(lat, lon), false);
            }
            
            const endLat = parseFloat(pts[pts.length-1].getAttribute("lat"));
            const endLon = parseFloat(pts[pts.length-1].getAttribute("lon"));
            await addRoutePoint(L.latLng(endLat, endLon), true);

            map.fitBounds(polyline.getBounds());
            
        } catch(err) {
            console.error(err);
            alert("B≈ÇƒÖd importu GPX");
        }
    };
    reader.readAsText(file);
}

/* ================= TRASOWANIE ================= */
async function getRouteSegment(start, end) {
    try {
        const url = `https://brouter.de/brouter?lonlats=${start.lng},${start.lat}|${end.lng},${end.lat}&profile=hiking-mountain&alternativeidx=0&format=geojson`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("Routing error");
        const data = await resp.json();
        
        if (data.features && data.features.length > 0) {
            const coords = data.features[0].geometry.coordinates.map(c => [c[1], c[0]]);
            const dist = data.features[0].properties['track-length'] || 0;
            return { coords, distance: parseFloat(dist) };
        }
        throw new Error("No path");
    } catch (e) {
        return { coords: [[start.lat, start.lng], [end.lat, end.lng]], distance: L.latLng(start).distanceTo(L.latLng(end)) }; 
    }
}

map.on('click', async e => {
    if (poiMode) { addPOI(e.latlng); poiMode = false; return; }
    if (isRouting) return; 
    await addRoutePoint(e.latlng, true);
});

async function addRoutePoint(latlng, recalc = true) {
    const pointId = Date.now() + Math.random();
    const m = L.circleMarker(latlng, { 
        radius: 8, color: '#fff', weight: 3, fillColor: '#22c55e', fillOpacity: 1, zIndexOffset: 1000 
    }).addTo(map);
    
    m.on('contextmenu', (ev) => {
        L.DomEvent.stopPropagation(ev);
        removePointById(pointId);
    });

    let elev = 0;
    try {
         const r = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${latlng.lat}&longitude=${latlng.lng}`);
         const d = await r.json();
         if(d.elevation) elev = d.elevation[0];
    } catch(e) {}
    
    routePoints.push({ id: pointId, latlng: latlng, marker: m, elevation: elev, distFromPrev: 0 });
    if (recalc) await recalculateRoute();
}

async function recalculateRoute() {
    if (isRouting) return; 
    isRouting = true;
    document.getElementById('loader').style.display = 'block';
    document.body.style.cursor = 'wait';

    try {
        routeGeometry = [];
        totalAscent = 0;
        
        if (routePoints.length === 0) {
            polyline.setLatLngs([]);
            updateStats(0);
            return;
        }

        routeGeometry = [[routePoints[0].latlng.lat, routePoints[0].latlng.lng]];
        
        for (let i = 1; i < routePoints.length; i++) {
            const res = await getRouteSegment(routePoints[i-1].latlng, routePoints[i].latlng);
            routePoints[i].distFromPrev = res.distance;
            routeGeometry = routeGeometry.concat(res.coords.slice(1));
        }

        polyline.setLatLngs(routeGeometry);
        
        await fetchFullElevationProfile();
        generateRouteDescription(); // Generuj opis od razu
        
    } catch(e) {
        console.error("Critical routing error", e);
    } finally {
        isRouting = false;
        document.getElementById('loader').style.display = 'none';
        document.body.style.cursor = 'default';
    }
}

/* ================= OPIS TRASY - AUTOWYKRYWANIE ZAKRƒòT√ìW ================= */
function getBearing(lat1, lon1, lat2, lon2) {
    const toRad = x => x * Math.PI / 180;
    const toDeg = x => x * 180 / Math.PI;
    const dLon = toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(toRad(lat2));
    const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) - Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
    let brng = toDeg(Math.atan2(y, x));
    return (brng + 360) % 360;
}

function getCompassDirection(brng) {
    if (brng >= 337.5 || brng < 22.5) return "na p√≥≈Çnoc";
    if (brng >= 22.5 && brng < 67.5) return "na p≈Çn-wsch√≥d";
    if (brng >= 67.5 && brng < 112.5) return "na wsch√≥d";
    if (brng >= 112.5 && brng < 157.5) return "na p≈Çd-wsch√≥d";
    if (brng >= 157.5 && brng < 202.5) return "na po≈Çudnie";
    if (brng >= 202.5 && brng < 247.5) return "na p≈Çd-zach√≥d";
    if (brng >= 247.5 && brng < 292.5) return "na zach√≥d";
    if (brng >= 292.5 && brng < 337.5) return "na p≈Çn-zach√≥d";
    return "";
}

function generateRouteDescription() {
    const container = document.getElementById('routeDescText');
    if (routeGeometry.length < 2) {
        container.innerHTML = "<em>Brak trasy do analizy.</em>";
        return;
    }

    let text = `<strong>Start:</strong> ${routePoints[0].elevation.toFixed(0)} m n.p.m.<br><br>`;
    
    // Algorytm spacerujƒÖcy po GEOMETRII trasy (nie tylko po punktach kontrolnych)
    // Grupujemy odcinki o podobnym azymucie.
    
    let steps = [];
    let currentStep = { direction: "", dist: 0 };
    
    // Pr√≥bkowanie co ~15 punkt√≥w geometrii (ok. 20-50m w terenie), ≈ºeby uniknƒÖƒá szum√≥w
    // Je≈õli trasa jest kr√≥tka, pr√≥bkujemy czƒô≈õciej.
    let sampleRate = Math.max(1, Math.floor(routeGeometry.length / 200)); 
    if (routeGeometry.length < 50) sampleRate = 1;

    for (let i = 0; i < routeGeometry.length - sampleRate; i += sampleRate) {
        const p1 = routeGeometry[i];
        // Patrzymy trochƒô w prz√≥d, ≈ºeby ustaliƒá og√≥lny kierunek
        const targetIdx = Math.min(i + sampleRate, routeGeometry.length - 1);
        const p2 = routeGeometry[targetIdx];
        
        const dist = L.latLng(p1).distanceTo(L.latLng(p2));
        if (dist < 5) continue; // Ignoruj mikroruchy

        const brng = getBearing(p1[0], p1[1], p2[0], p2[1]);
        const direction = getCompassDirection(brng);

        if (currentStep.direction === "") {
            currentStep.direction = direction;
            currentStep.dist = dist;
        } else if (currentStep.direction === direction) {
            currentStep.dist += dist;
        } else {
            // Zmiana kierunku - zapisz stary krok, zacznij nowy
            if (currentStep.dist > 20) { // Zapisz tylko je≈õli odcinek mia≈Ç sensownƒÖ d≈Çugo≈õƒá
                steps.push({...currentStep});
            }
            currentStep = { direction: direction, dist: dist };
        }
    }
    // Dodaj ostatni krok
    if (currentStep.dist > 0) steps.push(currentStep);

    // Renderowanie tekstu
    // Scalamy bardzo kr√≥tkie odcinki (zakrƒôty), je≈õli sƒÖ szumem, 
    // ale tutaj prosta logika jest czƒôsto najlepsza dla pieszego.
    steps.forEach((step, index) => {
        // Ignoruj bardzo ma≈Çe korekty (<30m) chyba ≈ºe to poczƒÖtek/koniec
        if (step.dist < 30 && index > 0 && index < steps.length - 1) return;
        
        let icon = "‚¨ÜÔ∏è";
        if (step.direction.includes("wsch√≥d")) icon = "‚û°Ô∏è";
        if (step.direction.includes("zach√≥d")) icon = "‚¨ÖÔ∏è";
        if (step.direction.includes("po≈Çudnie")) icon = "‚¨áÔ∏è";
        
        text += `<strong>${icon}</strong> Id≈∫ <strong>${step.direction}</strong> przez ${(step.dist).toFixed(0)}m.<br>`;
        // Dodaj separator co kilka krok√≥w dla czytelno≈õci
        if ((index + 1) % 5 === 0) text += "<hr style='margin:5px 0; opacity:0.3'>";
    });

    text += `<br>üèÅ <strong>Meta:</strong> ${routePoints[routePoints.length-1].elevation.toFixed(0)} m n.p.m.`;
    container.innerHTML = text;
}

/* ================= WYSOKO≈öƒÜ ================= */
async function fetchFullElevationProfile() {
    if (routeGeometry.length < 2) { clearElevation(); return; }
    
    const step = Math.max(1, Math.floor(routeGeometry.length / 80));
    const lats = [];
    const lngs = [];
    
    for(let i=0; i<routeGeometry.length; i+=step) {
        lats.push(routeGeometry[i][0]);
        lngs.push(routeGeometry[i][1]);
    }
    
    try {
        const url = `https://api.open-meteo.com/v1/elevation?latitude=${lats.join(',')}&longitude=${lngs.join(',')}`;
        const res = await fetch(url);
        const data = await res.json();
        const elevations = data.elevation;
        
        totalAscent = 0;
        for(let i=1; i<elevations.length; i++) {
            if(elevations[i] > elevations[i-1]) totalAscent += (elevations[i] - elevations[i-1]);
        }
        totalAscent = Math.round(totalAscent);
        
        drawElevation(elevations);
        updateStats(calculateTotalDist());
    } catch (e) { clearElevation(); }
}

function updateStats(distMeters) {
    const km = distMeters / 1000;
    document.getElementById('stats').innerText = `${km.toFixed(2)} km`;
    const speed = 4.2; 
    const minutes = (km / speed) * 60 + (totalAscent / 100 * 10);
    document.getElementById('time').innerText = `Czas: ~${Math.floor(minutes/60)}h ${Math.round(minutes%60)}m | ‚¨ÜÔ∏è ${totalAscent}m`;
}

function calculateTotalDist() {
    let d = 0;
    for (let i = 1; i < routeGeometry.length; i++) {
        d += L.latLng(routeGeometry[i-1]).distanceTo(L.latLng(routeGeometry[i]));
    }
    return d;
}

/* ================= INNE ================= */
function exportGPX() {
    if (routeGeometry.length < 2) return alert("Brak trasy");
    const startTime = new Date();
    const speedMs = 1.2; 
    let currentTime = new Date(startTime);
    let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Hiker Puszcza" xmlns="http://www.topografix.com/GPX/1/1">
<metadata><name>Wycieczka Puszcza</name><time>${startTime.toISOString()}</time></metadata>
<trk><name>Trasa Puszcza</name><trkseg>`;
    let prevPt = null;
    routeGeometry.forEach((p, index) => {
        if (index > 0 && prevPt) {
            const d = L.latLng(prevPt).distanceTo(L.latLng(p));
            currentTime.setSeconds(currentTime.getSeconds() + (d / speedMs));
        }
        prevPt = p;
        gpx += `\n<trkpt lat="${p[0]}" lon="${p[1]}"><time>${currentTime.toISOString()}</time></trkpt>`;
    });
    gpx += `\n</trkseg></trk>`;
    pois.forEach(p => { gpx += `\n<wpt lat="${p.latlng.lat}" lon="${p.latlng.lng}"><name>${p.name}</name></wpt>`; });
    gpx += `\n</gpx>`;
    const blob = new Blob([gpx], {type: "application/gpx+xml"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `trasa_puszcza_${new Date().toLocaleDateString()}.gpx`;
    a.click();
}

function clearElevation() {
    const c = document.getElementById('elevation');
    c.getContext('2d').clearRect(0,0,c.width,c.height);
}

function drawElevation(data) {
    const c = document.getElementById('elevation');
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    c.width = c.offsetWidth * dpr;
    c.height = c.offsetHeight * dpr;
    ctx.scale(dpr, dpr);
    const w = c.offsetWidth;
    const h = c.offsetHeight;
    if(data.length === 0) return;
    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = (max - min) < 10 ? 10 : (max - min);
    ctx.clearRect(0,0,w,h);
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, 'rgba(34, 197, 94, 0.4)');
    grad.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.moveTo(0, h);
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * (h - 20) - 10;
        ctx.lineTo(x, y);
    });
    ctx.lineTo(w, h); ctx.fillStyle = grad; ctx.fill();
    ctx.beginPath();
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * (h - 20) - 10;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 2; ctx.stroke();
}

function removePointById(id) {
    if (isRouting) return;
    const idx = routePoints.findIndex(p => p.id === id);
    if (idx > -1) {
        map.removeLayer(routePoints[idx].marker);
        routePoints.splice(idx, 1);
        recalculateRoute();
        renderPointsList();
    }
}
function movePoint(idx, direction) {
    if (isRouting) return;
    if (direction === 'up' && idx > 0) { [routePoints[idx], routePoints[idx-1]] = [routePoints[idx-1], routePoints[idx]]; }
    else if (direction === 'down' && idx < routePoints.length - 1) { [routePoints[idx], routePoints[idx+1]] = [routePoints[idx+1], routePoints[idx]]; }
    recalculateRoute(); renderPointsList();
}
function renderPointsList() {
    const list = document.getElementById('pointsList');
    list.innerHTML = routePoints.length === 0 ? "<p>Brak punkt√≥w na trasie.</p>" : "";
    routePoints.forEach((p, i) => {
        const item = document.createElement('div');
        item.className = 'point-item';
        const distText = i === 0 ? "START" : `+${(p.distFromPrev).toFixed(0)} m`;
        item.innerHTML = `
            <div class="point-info">
                <strong>Punkt ${i + 1}</strong> <small>(${p.elevation ? p.elevation.toFixed(0) : '?'} m n.p.m.)</small><br><span>${distText}</span>
            </div>
            <div class="point-actions">
                <button class="secondary" onclick="movePoint(${i}, 'up')" ${i===0?'disabled':''}>‚Üë</button>
                <button class="secondary" onclick="movePoint(${i}, 'down')" ${i===routePoints.length-1?'disabled':''}>‚Üì</button>
                <button class="danger" onclick="removePointById(${p.id})">üóëÔ∏è</button>
            </div>`;
        list.appendChild(item);
    });
}
function clearAll() {
    if (isRouting) return;
    routePoints.forEach(p => map.removeLayer(p.marker));
    pois.forEach(p => map.removeLayer(p.marker));
    routePoints = []; routeGeometry = []; pois = [];
    if(userMarker) map.removeLayer(userMarker);
    recalculateRoute();
}
function enablePOI() { poiMode = true; alert("Kliknij na mapƒô, by dodaƒá w≈Çasny opis."); }
function addPOI(latlng) {
    const name = prompt("Nazwa punktu:");
    if (!name) return;
    const m = L.marker(latlng).addTo(map).bindPopup(`<b>üìç ${name}</b>`).openPopup();
    pois.push({latlng, name, marker: m});
}
function toggleLayer(layer, cb) { if (cb.checked) map.addLayer(layer); else map.removeLayer(layer); }
function toggleTheme() {
    dark = !dark; document.body.className = dark ? "dark" : "light";
    map.removeLayer(dark ? tiles.light : tiles.dark); (dark ? tiles.dark : tiles.light).addTo(map);
}
function takeScreenshot() {
    const mapEl = document.getElementById('map');
    domtoimage.toPng(mapEl, { width: mapEl.clientWidth, height: mapEl.clientHeight })
    .then(dataUrl => { const link = document.createElement('a'); link.download = 'mapa_puszcza.png'; link.href = dataUrl; link.click(); });
}
function toggleSidebar() { document.getElementById('sidebar').classList.toggle('open'); }
async function loadOSMData() {
    const query = `[out:json][timeout:25];(relation["route"="hiking"](53.4,14.3,53.6,14.7);node["amenity"~"shelter|drinking_water|parking"](53.4,14.3,53.6,14.7);node["tourism"~"viewpoint|picnic_site|information"](53.4,14.3,53.6,14.7););out body;>;out skel qt;`;
    try {
        const resp = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
        if (!resp.ok) return;
        const data = await resp.json();
        const nodes = {}, ways = {};
        data.elements.filter(e => e.type === "node").forEach(n => nodes[n.id] = [n.lat, n.lon]);
        data.elements.filter(e => e.type === "way").forEach(w => ways[w.id] = w.nodes.map(nid => nodes[nid]));
        data.elements.filter(e => e.type === "relation").forEach(rel => {
            const sym = (rel.tags.osmc_symbol || rel.tags.color || "").toLowerCase();
            let color = '#888';
            if (sym.includes('red')) color = '#ef4444'; else if (sym.includes('blue')) color = '#3b82f6'; else if (sym.includes('green')) color = '#22c55e'; else if (sym.includes('yellow')) color = '#eab308'; else if (sym.includes('black')) color = '#000';
            rel.members.forEach(m => { if (m.type === "way" && ways[m.ref]) L.polyline(ways[m.ref], {color: color, weight: 4, opacity: 0.7, dashArray: '8, 8'}).bindTooltip(rel.tags.name || "Szlak").addTo(hikingLayer); });
        });
        data.elements.filter(e => e.type === "node" && e.tags).forEach(e => {
            let icon = 'üìç'; if(e.tags.amenity === 'shelter') icon = 'üõñ'; else if(e.tags.tourism === 'viewpoint') icon = 'üî≠'; else if(e.tags.amenity === 'parking') icon = 'üÖøÔ∏è';
            L.marker([e.lat, e.lon], {icon: L.divIcon({ html: `<div style="font-size:18px">${icon}</div>`, className: 'poi-icon' })}).bindPopup(`<b>${e.tags.name || "Punkt"}</b>`).addTo(poiLayer);
        });
    } catch (e) {}
}
loadOSMData();
</script>

</body>
</html>
