<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>GPX Hiker - Planer Puszczy Wkrza≈Ñskiej</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Leaflet & Plugins -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>

    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #f1f5f9;
            --accent: #22c55e;
            --danger: #ef4444;
            --modal-bg: rgba(15, 23, 42, 0.95);
        }
        .light {
            --bg: #f8fafc;
            --panel: #ffffff;
            --text: #0f172a;
            --accent: #16a34a;
            --modal-bg: rgba(255, 255, 255, 0.95);
        }
        body {
            margin: 0;
            height: 100vh;
            display: grid;
            grid-template-columns: 350px 1fr;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        
        /* Panel Boczny */
        aside {
            background: var(--panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        h3 { margin-top: 0; color: var(--accent); margin-bottom: 5px; }
        .subtitle { font-size: 0.85em; opacity: 0.8; margin-bottom: 15px; display: block;}

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            border: none;
            padding: 10px;
            border-radius: 6px;
            background: var(--accent);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        button.icon-only { padding: 10px; }

        .stat-card {
            background: rgba(0,0,0,0.1);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid var(--accent);
        }
        .stat-val { font-size: 1.2em; font-weight: bold; display: block; }
        
        #map { height: 100%; width: 100%; background: #ddd; position: relative; }
        
        canvas#elevation {
            height: 100px;
            width: 100%;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-top: 5px;
        }

        /* Opis trasy */
        #route-desc {
            font-size: 0.85em;
            background: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        /* Modal Styles */
        #pointsModal {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; max-width: 600px; max-height: 80vh;
            background: var(--panel); color: var(--text);
            border-radius: 12px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none; flex-direction: column; padding: 20px;
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .modal-body { overflow-y: auto; flex-grow: 1; }
        .point-item {
            display: flex; align-items: center; gap: 10px; padding: 10px;
            background: rgba(0,0,0,0.1); border-radius: 8px; margin-bottom: 8px; font-size: 0.9em;
        }
        .point-info { flex-grow: 1; }
        
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 1999; display: none;
        }

        .controls { font-size: 0.85em; background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; }
        hr { border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 10px 0; }
        
        /* Mobile Controls */
        #mobile-toggle { display: none; position: absolute; top: 10px; left: 10px; z-index: 1100; padding: 10px; border-radius: 50%; width: 45px; height: 45px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        #gps-btn { position: absolute; bottom: 20px; right: 20px; z-index: 900; width: 50px; height: 50px; border-radius: 50%; background: var(--panel); color: var(--accent); box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; border: 2px solid var(--accent); }

        @media (max-width: 768px) {
            body { grid-template-columns: 1fr; }
            aside {
                position: absolute; top: 0; left: 0; width: 85%; height: 100%;
                transform: translateX(-100%);
            }
            aside.open { transform: translateX(0); }
            #mobile-toggle { display: flex; }
            .leaflet-control-zoom { display: none; } /* Oszczƒôdzamy miejsce na mobile */
        }
    </style>
</head>
<body class="dark">

<button id="mobile-toggle" onclick="toggleSidebar()">‚ò∞</button>

<aside id="sidebar">
    <div>
        <h3>üå≤ GPX Hiker</h3>
        <span class="subtitle">Planer Puszczy Wkrza≈Ñskiej</span>
    </div>

    <div class="btn-group">
        <button onclick="toggleTheme()">üåì Motyw</button>
        <button onclick="takeScreenshot()">üì∏ Zrzut</button>
    </div>

    <div class="btn-group">
        <button class="secondary" onclick="exportGPX()">‚¨áÔ∏è Eksport</button>
        <button class="secondary" onclick="document.getElementById('fileInput').click()">‚¨ÜÔ∏è Import</button>
    </div>
    <input type="file" id="fileInput" hidden accept=".gpx" onchange="importGPX(event)">

    <button onclick="openPointsModal()">üìë Edycja Punkt√≥w Trasy</button>
    <button onclick="enablePOI()">üìç Dodaj W≈Çasny Punkt</button>
    <button class="danger" onclick="clearAll()">üóëÔ∏è Nowa Trasa</button>

    <hr>

    <div class="controls">
        <label><input type="checkbox" checked onchange="toggleLayer(hikingLayer, this)"> ü•æ Szlaki turystyczne</label><br>
        <label><input type="checkbox" checked onchange="toggleLayer(poiLayer, this)"> üõñ Wiaty i atrakcje</label>
    </div>

    <div class="stat-card">
        <span class="stat-val" id="stats">0.00 km</span>
        <small id="time">Czas: 0 min | ‚õ∞Ô∏è Podej≈õcia: 0m</small>
    </div>

    <div>
        <small>Profil terenu:</small>
        <canvas id="elevation"></canvas>
    </div>

    <div id="route-desc">
        <em>Tutaj pojawi siƒô opis trasy...</em>
    </div>
</aside>

<div id="map"></div>
<button id="gps-btn" onclick="locateUser()" title="Zlokalizuj mnie">üéØ</button>

<div class="overlay" id="overlay" onclick="closePointsModal()"></div>
<div id="pointsModal">
    <div class="modal-header">
        <h3>üìç Punkty Trasy</h3>
        <button class="danger" onclick="closePointsModal()">X</button>
    </div>
    <div class="modal-body" id="pointsList"></div>
</div>

<script>
/* ================= KONFIGURACJA MAPY ================= */
const map = L.map('map', { 
    zoomControl: false,
    preferCanvas: true 
}).setView([53.54, 14.55], 13); // Start w Policach/Puszczy

L.control.zoom({ position: 'topright' }).addTo(map);

let dark = true;
const tiles = {
    dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OSM', crossOrigin: true }),
    light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', crossOrigin: true })
};
tiles.dark.addTo(map);

let routePoints = []; 
let routeGeometry = []; 
let pois = [];
let poiMode = false;
let totalAscent = 0;
let userMarker = null;

const polyline = L.polyline([], {color: '#22c55e', weight: 6, opacity: 0.9, lineJoin: 'round'}).addTo(map);
const hikingLayer = L.layerGroup().addTo(map);
const poiLayer = L.layerGroup().addTo(map);

/* ================= LOKALIZACJA GPS ================= */
function locateUser() {
    map.locate({setView: true, maxZoom: 15});
}

map.on('locationfound', function(e) {
    if (userMarker) map.removeLayer(userMarker);
    userMarker = L.circleMarker(e.latlng, {
        radius: 8,
        fillColor: "#3b82f6",
        color: "#fff",
        weight: 3,
        opacity: 1,
        fillOpacity: 1
    }).addTo(map).bindPopup("Twoja pozycja").openPopup();
});

map.on('locationerror', function(e) {
    alert("Nie uda≈Ço siƒô ustaliƒá lokalizacji: " + e.message);
});

/* ================= IMPORT GPX (NAPRAWIONY) ================= */
// Funkcja importu, kt√≥ra unika "pajƒôczyny" poprzez sekwencyjne dodawanie punkt√≥w
function importGPX(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
        try {
            const xml = new DOMParser().parseFromString(ev.target.result, "text/xml");
            const pts = Array.from(xml.querySelectorAll("trkpt"));
            
            if (pts.length === 0) throw new Error("Pusty plik GPX");

            clearAll();
            
            // INTELIGENTNE UPRASZCZANIE:
            // Zamiast braƒá wszystko, bierzemy punkty co ~200-500 metr√≥w,
            // aby silnik BRouter m√≥g≈Ç "przykleiƒá" trasƒô do ≈õcie≈ºek, ale nie d≈Çawi≈Ç siƒô liczbƒÖ zapyta≈Ñ.
            // Dla bardzo ma≈Çych tras bierzemy czƒô≈õciej.
            
            const step = pts.length > 50 ? Math.floor(pts.length / 20) : 1; 
            
            // Dodajemy Start
            const startLat = parseFloat(pts[0].getAttribute("lat"));
            const startLon = parseFloat(pts[0].getAttribute("lon"));
            await addRoutePoint(L.latLng(startLat, startLon));

            // Dodajemy punkty po≈õrednie (sekwencyjnie!)
            for(let i = step; i < pts.length; i += step) {
                const lat = parseFloat(pts[i].getAttribute("lat"));
                const lon = parseFloat(pts[i].getAttribute("lon"));
                // WA≈ªNE: czekamy a≈º poprzedni punkt siƒô doda i przeliczy, zanim dodamy kolejny
                // Dziƒôki temu zachowujemy kolejno≈õƒá!
                await addRoutePoint(L.latLng(lat, lon), false); // false = nie przeliczaj ca≈Çej trasy jeszcze
            }
            
            // Dodajemy Koniec
            const endLat = parseFloat(pts[pts.length-1].getAttribute("lat"));
            const endLon = parseFloat(pts[pts.length-1].getAttribute("lon"));
            await addRoutePoint(L.latLng(endLat, endLon), true); // true = finalne przeliczenie

            map.fitBounds(polyline.getBounds());
            
        } catch(err) {
            console.error(err);
            alert("B≈ÇƒÖd importu GPX: " + err.message);
        }
    };
    reader.readAsText(file);
}

/* ================= TRASOWANIE I PUNKTY ================= */
async function getRouteSegment(start, end) {
    try {
        // BRouter: hiking-mountain dla najlepszych ≈õcie≈ºek
        const url = `https://brouter.de/brouter?lonlats=${start.lng},${start.lat}|${end.lng},${end.lat}&profile=hiking-mountain&alternativeidx=0&format=geojson`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error("Routing error");
        const data = await resp.json();
        
        if (data.features && data.features.length > 0) {
            const coords = data.features[0].geometry.coordinates.map(c => [c[1], c[0]]);
            const dist = data.features[0].properties['track-length'] || 0;
            return { coords, distance: parseFloat(dist) };
        }
        throw new Error("No path");
    } catch (e) {
        // Fallback do prostej linii
        return { coords: [[start.lat, start.lng], [end.lat, end.lng]], distance: L.latLng(start).distanceTo(L.latLng(end)) }; 
    }
}

map.on('click', async e => {
    if (poiMode) { addPOI(e.latlng); poiMode = false; return; }
    await addRoutePoint(e.latlng, true);
});

async function addRoutePoint(latlng, recalc = true) {
    const pointId = Date.now() + Math.random(); // unikalne ID
    const m = L.circleMarker(latlng, { 
        radius: 8, color: '#fff', weight: 3, fillColor: '#22c55e', fillOpacity: 1, zIndexOffset: 1000 
    }).addTo(map);
    
    m.on('contextmenu', (ev) => {
        L.DomEvent.stopPropagation(ev);
        removePointById(pointId);
    });

    // Pobieramy wysoko≈õƒá dla punktu kontrolnego
    let elev = 0;
    try {
         const r = await fetch(`https://api.open-meteo.com/v1/elevation?latitude=${latlng.lat}&longitude=${latlng.lng}`);
         const d = await r.json();
         if(d.elevation) elev = d.elevation[0];
    } catch(e) {}
    
    routePoints.push({
        id: pointId,
        latlng: latlng,
        marker: m,
        elevation: elev,
        distFromPrev: 0
    });

    if (recalc) await recalculateRoute();
}

async function recalculateRoute() {
    routeGeometry = [];
    totalAscent = 0;
    
    if (routePoints.length === 0) {
        polyline.setLatLngs([]);
        updateStats(0);
        document.getElementById('route-desc').innerHTML = "<em>Dodaj punkty na mapie...</em>";
        return;
    }

    routeGeometry = [[routePoints[0].latlng.lat, routePoints[0].latlng.lng]];
    
    // Obliczanie segment√≥w
    for (let i = 1; i < routePoints.length; i++) {
        const res = await getRouteSegment(routePoints[i-1].latlng, routePoints[i].latlng);
        routePoints[i].distFromPrev = res.distance;
        routeGeometry = routeGeometry.concat(res.coords.slice(1));
    }

    polyline.setLatLngs(routeGeometry);
    const totalDist = calculateTotalDist();
    
    await fetchFullElevationProfile(); // To te≈º zaktualizuje statystyki
    generateRouteDescription();
}

/* ================= OPIS TRASY (NARRATOR) ================= */
function generateRouteDescription() {
    const container = document.getElementById('route-desc');
    if (routePoints.length < 2) {
        container.innerHTML = "<em>Zaznacz min. 2 punkty by wygenerowaƒá opis.</em>";
        return;
    }

    let text = `<strong>üìñ Opis trasy:</strong>\n`;
    text += `Startujesz z wysoko≈õci ${routePoints[0].elevation.toFixed(0)} m n.p.m.\n`;

    for (let i = 1; i < routePoints.length; i++) {
        const p1 = routePoints[i-1].latlng;
        const p2 = routePoints[i].latlng;
        const dist = routePoints[i].distFromPrev;
        
        // Obliczanie azymutu
        const y = Math.sin(p2.lng - p1.lng) * Math.cos(p2.lat);
        const x = Math.cos(p1.lat) * Math.sin(p2.lat) - Math.sin(p1.lat) * Math.cos(p2.lat) * Math.cos(p2.lng - p1.lng);
        const brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        
        let direction = "na p√≥≈Çnoc";
        if (brng >= 22.5 && brng < 67.5) direction = "na p√≥≈Çnocny-wsch√≥d";
        else if (brng >= 67.5 && brng < 112.5) direction = "na wsch√≥d";
        else if (brng >= 112.5 && brng < 157.5) direction = "na po≈Çudniowy-wsch√≥d";
        else if (brng >= 157.5 && brng < 202.5) direction = "na po≈Çudnie";
        else if (brng >= 202.5 && brng < 247.5) direction = "na po≈Çudniowy-zach√≥d";
        else if (brng >= 247.5 && brng < 292.5) direction = "na zach√≥d";
        else if (brng >= 292.5 && brng < 337.5) direction = "na p√≥≈Çnocny-zach√≥d";

        text += `‚Ä¢ Odcinek ${i}: Kieruj siƒô <strong>${direction}</strong> przez ok. ${(dist).toFixed(0)}m.\n`;
    }
    
    text += `\nüèÅ Meta na wysoko≈õci ${routePoints[routePoints.length-1].elevation.toFixed(0)} m n.p.m.`;
    container.innerHTML = text.replace(/\n/g, '<br>');
}

/* ================= NOWA WYSOKO≈öƒÜ (OPEN-METEO) ================= */
async function fetchFullElevationProfile() {
    if (routeGeometry.length < 2) { clearElevation(); return; }
    
    // Upraszczanie do max 100 punkt√≥w dla zapytania API
    const step = Math.max(1, Math.floor(routeGeometry.length / 80));
    const lats = [];
    const lngs = [];
    
    for(let i=0; i<routeGeometry.length; i+=step) {
        lats.push(routeGeometry[i][0]);
        lngs.push(routeGeometry[i][1]);
    }
    
    try {
        const url = `https://api.open-meteo.com/v1/elevation?latitude=${lats.join(',')}&longitude=${lngs.join(',')}`;
        const res = await fetch(url);
        const data = await res.json();
        const elevations = data.elevation;
        
        // Obliczanie przewy≈ºsze≈Ñ
        totalAscent = 0;
        for(let i=1; i<elevations.length; i++) {
            if(elevations[i] > elevations[i-1]) totalAscent += (elevations[i] - elevations[i-1]);
        }
        totalAscent = Math.round(totalAscent);
        
        drawElevation(elevations);
        updateStats(calculateTotalDist()); // Aktualizacja statystyk z nowym ascentem
    } catch (e) { 
        console.error("Elevation error (Open-Meteo)", e);
        // W razie b≈Çƒôdu API rysujemy p≈Çaski wykres
        clearElevation();
    }
}

function updateStats(distMeters) {
    const km = distMeters / 1000;
    document.getElementById('stats').innerText = `${km.toFixed(2)} km`;
    const speed = 4.2; 
    const minutes = (km / speed) * 60 + (totalAscent / 100 * 10);
    document.getElementById('time').innerText = `Czas: ~${Math.floor(minutes/60)}h ${Math.round(minutes%60)}m | ‚¨ÜÔ∏è ${totalAscent}m`;
}

/* ================= EKSPORT GPX Z CZASEM (ANIMACJA) ================= */
function exportGPX() {
    if (routeGeometry.length < 2) return alert("Brak trasy");
    
    const startTime = new Date();
    const speedMs = 1.2; // ~4.3 km/h
    let currentTime = new Date(startTime);

    let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Hiker Puszcza" xmlns="http://www.topografix.com/GPX/1/1">
<metadata>
    <name>Wycieczka Puszcza Wkrza≈Ñska</name>
    <desc>Trasa wygenerowana w GPX Hiker. Dystans: ${(calculateTotalDist()/1000).toFixed(2)}km.</desc>
    <time>${startTime.toISOString()}</time>
</metadata>
<trk><name>Trasa Puszcza</name><trkseg>`;
    
    let prevPt = null;

    routeGeometry.forEach((p, index) => {
        // Symulacja czasu dla animacji
        if (index > 0 && prevPt) {
            const d = L.latLng(prevPt).distanceTo(L.latLng(p));
            const seconds = d / speedMs;
            currentTime.setSeconds(currentTime.getSeconds() + seconds);
        }
        prevPt = p;

        gpx += `\n<trkpt lat="${p[0]}" lon="${p[1]}"><time>${currentTime.toISOString()}</time></trkpt>`;
    });

    gpx += `\n</trkseg></trk>`;
    
    pois.forEach(p => {
        gpx += `\n<wpt lat="${p.latlng.lat}" lon="${p.latlng.lng}"><name>${p.name}</name></wpt>`;
    });
    
    gpx += `\n</gpx>`;

    const blob = new Blob([gpx], {type: "application/gpx+xml"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `trasa_puszcza_${new Date().toLocaleDateString()}.gpx`;
    a.click();
}

/* ================= POZOSTA≈ÅE FUNKCJE (UI, RYSOWANIE) ================= */
function calculateTotalDist() {
    let d = 0;
    for (let i = 1; i < routeGeometry.length; i++) {
        d += L.latLng(routeGeometry[i-1]).distanceTo(L.latLng(routeGeometry[i]));
    }
    return d;
}

function clearElevation() {
    const c = document.getElementById('elevation');
    c.getContext('2d').clearRect(0,0,c.width,c.height);
}

function drawElevation(data) {
    const c = document.getElementById('elevation');
    const ctx = c.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    c.width = c.offsetWidth * dpr;
    c.height = c.offsetHeight * dpr;
    ctx.scale(dpr, dpr);
    const w = c.offsetWidth;
    const h = c.offsetHeight;
    if(data.length === 0) return;
    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = (max - min) < 10 ? 10 : (max - min); // min range to avoid flat line issues

    ctx.clearRect(0,0,w,h);
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, 'rgba(34, 197, 94, 0.4)');
    grad.addColorStop(1, 'transparent');

    ctx.beginPath();
    ctx.moveTo(0, h);
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * (h - 20) - 10; // padding
        ctx.lineTo(x, y);
    });
    ctx.lineTo(w, h);
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    data.forEach((v, i) => {
        const x = (i / (data.length - 1)) * w;
        const y = h - ((v - min) / range) * (h - 20) - 10;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = '#22c55e';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function removePointById(id) {
    const idx = routePoints.findIndex(p => p.id === id);
    if (idx > -1) {
        map.removeLayer(routePoints[idx].marker);
        routePoints.splice(idx, 1);
        recalculateRoute();
        renderPointsList();
    }
}

function movePoint(idx, direction) {
    if (direction === 'up' && idx > 0) {
        [routePoints[idx], routePoints[idx-1]] = [routePoints[idx-1], routePoints[idx]];
    } else if (direction === 'down' && idx < routePoints.length - 1) {
        [routePoints[idx], routePoints[idx+1]] = [routePoints[idx+1], routePoints[idx]];
    }
    recalculateRoute();
    renderPointsList();
}

function openPointsModal() {
    document.getElementById('overlay').style.display = 'block';
    document.getElementById('pointsModal').style.display = 'flex';
    renderPointsList();
}

function closePointsModal() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('pointsModal').style.display = 'none';
}

function renderPointsList() {
    const list = document.getElementById('pointsList');
    list.innerHTML = routePoints.length === 0 ? "<p>Brak punkt√≥w na trasie.</p>" : "";
    routePoints.forEach((p, i) => {
        const item = document.createElement('div');
        item.className = 'point-item';
        const distText = i === 0 ? "START" : `+${(p.distFromPrev).toFixed(0)} m`;
        item.innerHTML = `
            <div class="point-info">
                <strong>Punkt ${i + 1}</strong> <small>(${p.elevation ? p.elevation.toFixed(0) : '?'} m n.p.m.)</small><br>
                <span>${distText}</span>
            </div>
            <div class="point-actions">
                <button class="secondary" onclick="movePoint(${i}, 'up')" ${i===0?'disabled':''}>‚Üë</button>
                <button class="secondary" onclick="movePoint(${i}, 'down')" ${i===routePoints.length-1?'disabled':''}>‚Üì</button>
                <button class="danger" onclick="removePointById(${p.id})">üóëÔ∏è</button>
            </div>
        `;
        list.appendChild(item);
    });
}

async function loadOSMData() {
    const query = `[out:json][timeout:25];
    (
      relation["route"="hiking"](53.4,14.3,53.6,14.7);
      node["amenity"~"shelter|drinking_water|parking"](53.4,14.3,53.6,14.7);
      node["tourism"~"viewpoint|picnic_site|information"](53.4,14.3,53.6,14.7);
    );
    out body; >; out skel qt;`;

    try {
        const resp = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
        if (!resp.ok) return;
        const data = await resp.json();

        const nodes = {};
        data.elements.filter(e => e.type === "node").forEach(n => nodes[n.id] = [n.lat, n.lon]);
        const ways = {};
        data.elements.filter(e => e.type === "way").forEach(w => ways[w.id] = w.nodes.map(nid => nodes[nid]));

        data.elements.filter(e => e.type === "relation").forEach(rel => {
            const sym = (rel.tags.osmc_symbol || rel.tags.color || "").toLowerCase();
            let color = '#888';
            if (sym.includes('red')) color = '#ef4444';
            else if (sym.includes('blue')) color = '#3b82f6';
            else if (sym.includes('green')) color = '#22c55e';
            else if (sym.includes('yellow')) color = '#eab308';
            else if (sym.includes('black')) color = '#000';

            rel.members.forEach(m => {
                if (m.type === "way" && ways[m.ref]) {
                    L.polyline(ways[m.ref], {
                        color: color, weight: 4, opacity: 0.7, dashArray: '8, 8'
                    }).bindTooltip(rel.tags.name || "Szlak").addTo(hikingLayer);
                }
            });
        });

        data.elements.filter(e => e.type === "node" && e.tags).forEach(e => {
            let icon = 'üìç';
            if(e.tags.amenity === 'shelter') icon = 'üõñ';
            else if(e.tags.tourism === 'viewpoint') icon = 'üî≠';
            else if(e.tags.amenity === 'parking') icon = 'üÖøÔ∏è';

            L.marker([e.lat, e.lon], {
                icon: L.divIcon({ html: `<div style="font-size:18px">${icon}</div>`, className: 'poi-icon' })
            }).bindPopup(`<b>${e.tags.name || "Punkt"}</b>`).addTo(poiLayer);
        });
    } catch (e) {}
}
loadOSMData();

function toggleTheme() {
    dark = !dark;
    document.body.className = dark ? "dark" : "light";
    map.removeLayer(dark ? tiles.light : tiles.dark);
    (dark ? tiles.dark : tiles.light).addTo(map);
}

function takeScreenshot() {
    const mapEl = document.getElementById('map');
    domtoimage.toPng(mapEl, { width: mapEl.clientWidth, height: mapEl.clientHeight })
    .then(dataUrl => {
        const link = document.createElement('a');
        link.download = 'mapa_puszcza.png';
        link.href = dataUrl;
        link.click();
    });
}

function clearAll() {
    routePoints.forEach(p => map.removeLayer(p.marker));
    pois.forEach(p => map.removeLayer(p.marker));
    routePoints = []; routeGeometry = []; pois = [];
    if(userMarker) map.removeLayer(userMarker);
    recalculateRoute();
}

function enablePOI() {
    poiMode = true;
    alert("Kliknij na mapƒô, by dodaƒá w≈Çasny opis.");
}

function addPOI(latlng) {
    const name = prompt("Nazwa punktu:");
    if (!name) return;
    const m = L.marker(latlng).addTo(map).bindPopup(`<b>üìç ${name}</b>`).openPopup();
    pois.push({latlng, name, marker: m});
}

function toggleLayer(layer, cb) {
    if (cb.checked) map.addLayer(layer); else map.removeLayer(layer);
}

/* UI Mobile */
function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
}
</script>

</body>
</html>
